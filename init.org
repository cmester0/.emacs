* What to write in the .emacs file:
#+BEGIN_SRC emacs-lisp :tangle no
(require 'org)
(org-babel-load-file (expand-file-name "~/Documents/.emacs/init.org"))

;; (require 'package)
;; (setq package-enable-at-startup nil)
;; (add-to-list 'package-archieves '("melpa" . "https://melpa.org/packages/") t)
;; (package-initialize)

;; (add-to-list 'package-archieves '("melpa-stable" . "https://stable.melpa.org/packages/") t)
#+END_SRC

* Better start
#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(inhibit-startup-screen t))

(setq make-backup-files nil) ; stop creating backup~ files
(setq auto-save-default nil) ; stop creating #autosave# files
(setq create-lockfiles nil) ; stop creating .#autosave files

(setq visible-bell t) ; os / emacs sounds off

(menu-bar-mode -1) ; Don't show menu bar
(tool-bar-mode -1) ; Don't show tool bar

(line-number-mode 1)   ;; Show line number
(column-number-mode 1) ;; Show column number

(setq debug-on-error 1) ;; Show backtrace on emacs lisp error

;; Relative scrolling
(setq scroll-conservatively 100)
(setq scroll-margin 7)
#+END_SRC
* Using Emacs
C-h m -- show current modes
* Ubuntu installs
#+BEGIN_SRC bash :tangle no
sudo apt install texlive-full
sudo apt install opam
opam install coq

gsettings set org.freedesktop.ibus.panel.emoji hotkey "[]" # removes weird ctrl . and ctrl shift u interactions.
sudo apt-get install clangd-12 # LSP mode
// TODO: https://nixos.org/
sudo apt-get install fonts-noto
#+END_SRC
** Printer setup
You are going to install following packages.
   hl1210wlpr-3.0.1-1.i386.deb
   hl1210wcupswrapper-3.0.1-1.i386.deb
Check link: https://support.brother.com/g/b/downloadtop.aspx?c=dk&lang=da&prod=hl1210w_eu_as
* Install missing packages
#+BEGIN_SRC emacs-lisp
(require 'use-package)
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
;; (package-initialize)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(mapcar
 (lambda (package)
   (unless (package-installed-p package)
     (package-install package)))
 '(auctex
   sml-mode
   ;; magit
   ;; multiple-cursors
   rainbow-delimiters
   ;; tuareg
   flycheck
   flycheck-color-mode-line
   powerline
   company
   company-auctex
   company-coq
   company-rtags
   scala-mode
   haskell-mode
   proof-general
   smartparens
   exec-path-from-shell))
#+END_SRC
* Looks
** Theme
#+BEGIN_SRC emacs-lisp
(load-theme 'wheatgrass)
;; alternatives: manoj-dark  ,  tango-dark  ,  tsdh-dark  ,  wheatgrass  , wombat
#+END_SRC
** Pretty symbol modes
#+BEGIN_SRC emacs-lisp
  (setq read-quoted-char-radix 10)
  ;; C-q use decimal codes (quoted-insert)


  (defun pretty-symbols-preview-latex ()
    "make some word or string show as pretty Unicode symbols"
    (setq prettify-symbols-alist
	  (append
	   '(("lambda" . 955) ; Î»
	     ("<-" . 8592) ; â†
	     ("->" . 8594) ; â†’
	     ("<->" . 8596) ; â†”
	     ("=>" . 8658) ; â‡’
	     ("<=>" . 8660) ; â‡”
	     ("\\circ" . 9702) ; â—¦
	     ("|[" . 10214) ; âŸ¦
	     ("|]" . 10215) ; âŸ§
	     ("\\[" . 9128) ; âŽ¨
	     ("\\]" . 9132) ; âŽ¬
	     ("\\(" . "(")
	     ("\\)" . ")")
	     ("\\land" . 8743) ; âˆ§
	     ("\\lor" . 8744) ; âˆ¨
	     ("\\subset" . 8834) ; âŠ‚
	     ("\\subseteq" . 8838) ; âŠ†
	     ("\\mathbb{A}" . 120120) ; ð”¸
	     ("\\mathbb{B}" . 120121) ; ð”¹
	     ("\\mathbb{C}" . 8450) ; â„‚
	     ("\\mathbb{D}" . 120123) ; ð”»
	     ("\\mathbb{E}" . 120124) ; ð”¼
	     ("\\mathbb{F}" . 120125) ; ð”½
	     ("\\mathbb{G}" . 120126) ; ð”¾
	     ("\\mathbb{H}" . 8461) ; â„
	     ("\\mathbb{I}" . 120128) ; ð•€
	     ("\\mathbb{J}" . 120129) ; ð•
	     ("\\mathbb{K}" . 120130) ; ð•‚
	     ("\\mathbb{L}" . 120131) ; ð•ƒ
	     ("\\mathbb{M}" . 120132) ; ð•„
	     ("\\mathbb{N}" . 8469) ; â„•
	     ("\\mathbb{O}" . 120134) ; ð•†
	     ("\\mathbb{P}" . 8473) ; â„™
	     ("\\mathbb{Q}" . 8474) ; â„š
	     ("\\mathbb{R}" . 8477) ; â„
	     ("\\mathbb{S}" . 120138) ; ð•Š
	     ("\\mathbb{T}" . 120139) ; ð•‹
	     ("\\mathbb{U}" . 120140) ; ð•Œ
	     ("\\mathbb{V}" . 120141) ; ð•
	     ("\\mathbb{W}" . 120142) ; ð•Ž
	     ("\\mathbb{X}" . 120143) ; ð•
	     ("\\mathbb{Y}" . 120144) ; ð•
	     ("\\mathbb{Z}" . 8484) ; â„¤
	     ("\\mathcal{A}" . 119964) ; ð’œ
	     ("\\mathcal{B}" . 8492) ; â„¬
	     ("\\mathcal{C}" . 119966) ; ð’ž
	     ("\\mathcal{D}" . 119967) ; ð’Ÿ
	     ("\\mathcal{E}" . 8496) ; â„°
	     ("\\mathcal{F}" . 8497) ; â„±
	     ("\\mathcal{G}" . 119970) ; ð’¢
	     ("\\mathcal{H}" . 8459) ; â„‹
	     ("\\mathcal{I}" . 8464) ; â„
	     ("\\mathcal{J}" . 119973) ; ð’¥
	     ("\\mathcal{K}" . 119974) ; ð’¦
	     ("\\mathcal{L}" . 8466) ; â„’
	     ("\\mathcal{M}" . 8499) ; â„³
	     ("\\mathcal{N}" . 119977) ; ð’©
	     ("\\mathcal{O}" . 119978) ; ð’ª
	     ("\\mathcal{P}" . 119979) ; ð’«
	     ("\\mathcal{Q}" . 119980) ; ð’¬
	     ("\\mathcal{R}" . 8475) ; â„›
	     ("\\mathcal{S}" . 119982) ; ð’®
	     ("\\mathcal{T}" . 119983) ; ð’¯
	     ("\\mathcal{U}" . 119984) ; ð’°
	     ("\\mathcal{V}" . 119985) ; ð’±
	     ("\\mathcal{W}" . 119986) ; ð’²
	     ("\\mathcal{X}" . 119987) ; ð’³
	     ("\\mathcal{Y}" . 119988) ; ð’´
	     ("\\mathcal{Z}" . 119989) ; ð’µ
	     ("\\ell" . 8467) ; â„“
	     ("\\qquad" . 12061) ; â¼
	     ("\\dots" . 8230) ; â€¦
	     ("\\cdots" . 8943) ; â‹¯
	     ("\\bigsqcap" . 10757) ; â¨…
	     ("\\bigsqcup" . 10758) ; â¨†
	     ("\\rightsquigarrow" . 8669) ; â‡
	     ("|-" . 8866) ; âŠ¢
	     ("\\not\\equiv" . 8802) ; â‰¢
	     ("\\llbracket" . 10214) ; âŸ¦
	     ("\\rrbracket" . 10215) ; âŸ§
	     ("\\\\[" . "[") ;
	     ("\\set{" . "{") ;
	     )
	   prettify-symbols-alist ;; tex--prettify-symbols-alist
	   )))


  (setq inhibit-compacting-font-caches t)

  ;;AUCTeX
  (add-hook 'tex-mode-hook 'pretty-symbols-preview-latex)
  (add-hook 'latex-mode-hook 'pretty-symbols-preview-latex)
  (add-hook 'LaTeX-mode-hook 'pretty-symbols-preview-latex)

  ;; Uncomment to unfold definitions when hovered:
					  ; (setq prettify-symbols-unprettify-at-point t)

  (global-prettify-symbols-mode 1)
#+END_SRC
* Util
** Display Batery Mode
#+BEGIN_SRC emacs-lisp
;; (display-battery-mode 1) ;; does not work on computer without battery
#+END_SRC

** CEDETs
*** Semantic
#+BEGIN_SRC emacs-lisp
  (require 'cc-mode)
  (require 'semantic)

  (semantic-mode 1)

  ;; (global-semantic-idle-completions-mode) ;; AUTO-COMPLETE

  (semantic-add-system-include "~/linux/kernel")
  (semantic-add-system-include "~/linux/include")

  (add-to-list 'semantic-default-submodes 'global-semanticdb-minor-mode)
  (add-to-list 'semantic-default-submodes 'global-semantic-mru-bookmark-mode)
  (add-to-list 'semantic-default-submodes 'global-semanticdb-minor-mode)
  (add-to-list 'semantic-default-submodes 'global-semantic-idle-scheduler-mode)
  (add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode) ;; COMMENT OUT
  (add-to-list 'semantic-default-submodes 'global-cedet-m3-minor-mode)
  (add-to-list 'semantic-default-submodes 'global-semantic-highlight-func-mode)
  (add-to-list 'semantic-default-submodes 'global-semantic-show-unmatched-syntax-mode) ;; COMMENT OUT
  (add-to-list 'semantic-default-submodes 'global-semantic-highlight-edits-mode)  ;; COMMENT OUT
  (add-to-list 'semantic-default-submodes 'global-semantic-show-parser-state-mode)  ;; COMMENT OUT

  (require 'semantic/ia)
  (require 'semantic/bovine/c)
  (require 'semantic/bovine/gcc)

  (setq semantic-complete-inline-analyzer-displayor-class
	'semantic-displayor-ghost)
#+END_SRC

*** EDE
** Parenthesis matching
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-)") (quote check-parens))
(show-paren-mode)

(require 'rainbow-delimiters)
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
;; (global-rainbow-delimiters-mode)
#+END_SRC
** Whitespace rendering
#+BEGIN_SRC emacs-lisp
(setq-default show-trailing-whitespace t)
(setq-default missing-newline-at-eof t)
#+END_SRC
* Inputs
** Keyboard setup (QMK)
#+BEGIN_SRC bash :tangle no
  git clone git@github.com:cmester0/keyboard_setup.git
#+END_SRC
* Fonts
You may find `M-x list-faces-display` or `M-x list-colors-display` helpful. And `C-u C-x =` to check data under cursor. Or even: `customize-face`.

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8-unix)

;; Font test: â„•ð“Ÿâ§ºÃ—â‰ â‰¥â‰¤Â±Â¬âˆ¨âˆ§âˆƒâˆ€Î»âŸ¿âŸ¹âŠ¥âŠ¤âŠ¢
;; Font emoji test: â¤ðŸ§¡ðŸ’›ðŸ’šðŸ’™ðŸ’œ ðŸ«€

(set-face-attribute 'default nil :family "Noto Mono")
;; (set-frame-font "Noto Mono 13" nil t)

;; (set-fontset-font t 'unicode (font-spec :family "Noto Mono" :height 100) nil 'append)

;; DejaVu Sans Mono ; Noto Mono ; Roboto Mono

(custom-set-faces
 '(default ((t (:foreground "white" :stipple nil :weight normal :height 150 :width normal))))
 '(variable-pitch ((t (:family "Noto Sans" :height 150 :weight light)))))

(if (>= emacs-major-version 27)
    (set-fontset-font t '(#x2764 . #x2764)
              (font-spec :family "Noto Color Emoji")))
(if (>= emacs-major-version 27)
    (set-fontset-font t '(#x1f499 . #x1f49c)
              (font-spec :family "Noto Color Emoji")))
(if (>= emacs-major-version 27)
    (set-fontset-font t '(#x1f7e5 . #x1f9e1)
              (font-spec :family "Noto Color Emoji")))
(if (>= emacs-major-version 27)
    (set-fontset-font t '(#x1f534 . #x1f535)
              (font-spec :family "Noto Color Emoji")))
(if (>= emacs-major-version 27)
    (set-fontset-font t '(#x1f7e0 . #x1f7e3)
              (font-spec :family "Noto Color Emoji")))
(if (>= emacs-major-version 27)
    (set-fontset-font t '(#x26aa . #x26ab)
              (font-spec :family "Noto Color Emoji")))
#+END_SRC

** Font-lock-*
#+BEGIN_SRC emacs-lisp
  (custom-set-faces
   '(font-lock-builtin-face ((t :foreground "LightSteelBlue")))
   '(font-lock-comment-delimiter-face ((t :foreground "gray50"))) ;; :inherit 'font-lock-comment-face
   '(font-lock-comment-face ((t :foreground "gray50"))) ;; gray50
   '(font-lock-constant-face ((t :foreground "sky blue"))) ;; turquoise
   '(font-lock-doc-face ((t :foreground "light orange"))) ;; :inherit 'font-lock-string-face
   '(font-lock-function-name-face ((t :foreground "cyan"))) ;; pale green
   '(font-lock-keyword-face ((t :foreground "gray70"))) ;; white
   '(font-lock-negation-char-face)
   '(font-lock-preprocessor-face ((t :foreground "royal blue"))) ;; :inherit 'font-lock-builtin-face
   '(font-lock-regexp-grouping-backslash ((t :inherit 'bold)))
   '(font-lock-regexp-grouping-construct ((t :inherit 'bold)))
   '(font-lock-string-face ((t :foreground "dark khaki")))
   '(font-lock-type-face ((t :foreground "green"))) ;; aquamarine
   '(font-lock-variable-name-face ((t :foreground "yellow green"))) ;;
   '(font-lock-warning-face ((t :foreground "salmon1")))) ;; :inherit (t (:inherit 'error))
#+END_SRC

** Rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (custom-set-faces
   '(rainbow-delimiters-depth-1-face ((t (:foreground "purple3"))))
   '(rainbow-delimiters-depth-2-face ((t (:foreground "red3"))))
   '(rainbow-delimiters-depth-3-face ((t (:foreground "orange3"))))
   '(rainbow-delimiters-depth-4-face ((t (:foreground "yellow3"))))
   '(rainbow-delimiters-depth-5-face ((t (:foreground "green3"))))
   '(rainbow-delimiters-depth-6-face ((t (:foreground "cyan3"))))
   '(rainbow-delimiters-depth-7-face ((t (:foreground "blue3"))))
   '(rainbow-delimiters-depth-8-face ((t (:foreground "magenta3"))))
   '(rainbow-delimiters-depth-9-face ((t (:foreground "DeepPink3"))))
   '(rainbow-delimiters-base-face ((t (:background: ""))))
   '(rainbow-delimiters-mismatched-face ((t (:foreground "blue" :inherit 'rainbow-delimiters-base-face))))
   '(rainbow-delimiters-unmatched-face ((t (:foreground "blue" :background "yellow3" :inherit 'rainbow-delimiters-base-face)))))
#+END_SRC

** Smart mode line
#+begin_src emacs-lisp
(setq sml/no-confirm-load-theme t)

(sml/setup)
;; (setq sml/theme 'dark)
(setq sml/theme 'light)
;; (setq sml/theme 'respectful)
#+end_src

** Modes
*** Org mode
#+BEGIN_SRC emacs-lisp
;; Basics
(custom-set-faces
 '(org-level-1 ((t (:foreground "purple1"))))
 '(org-level-2 ((t (:foreground "red1"))))
 '(org-level-3 ((t (:foreground "orange1"))))
 '(org-level-4 ((t (:foreground "yellow1"))))
 '(org-level-5 ((t (:foreground "green1"))))
 '(org-level-6 ((t (:foreground "cyan1"))))
 '(org-level-7 ((t (:foreground "blue1"))))
 '(org-level-8 ((t (:foreground "magenta1"))))
 '(org-block ((t (:foreground "gray70" :background "gray10")))) ; ((t (:inherit 'shadow))) (gray70)
 '(org-default ((t (:inherit 'default))))
 '(org-block-begin-line ((t (:foreground "dim gray")))) ; ((t (:inherit 'org-meta-line)))
 '(org-block-end-line ((t (:foreground "dim gray")))) ; ((t (:inherit 'org-meta-line)))
 '(org-meta-line ((t (:foreground "red3")))) ;; (:inherit 'font-lock-comment-face)
 )
#+END_SRC

*** Agda mode
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(agda2-highlight-keyword-face ((t (:foreground "magenta"))))
 '(agda2-highlight-catchall-clause-face ((t (:foreground "dark olive green"))))
 '(agda2-highlight-unsolved-meta-face ((t (:background "dark goldenrod"))))
 '(agda2-highlight-unsolved-constraint-face ((t (:background "olive green"))))
 '(agda2-highlight-typechecks-face ((t (:background "dark olive green"))))
 '(agda2-highlight-catchal-clause-face ((t (:background "dark red"))))
 '(agda2-highlight-coverage-problem-face ((t (:background "dark red"))))
 '(agda2-highlight-bound-variable-face ((t (:foreground "green"))))
 '(agda2-highlight-datatype-face ((t (:foreground "blue"))))
 '(agda2-highlight-function-face ((t (:foreground "cyan"))))
 '(agda2-highlight-inductive-constructor-face ((t (:foreground "Orange"))))
 '(agda2-highlight-module-face ((t (:foreground "controlLightHighlightColor"))))
 '(agda2-highlight-number-face ((t (:foreground "Orange"))))
 '(agda2-highlight-operator-face ((t (:foreground "Green"))))
 '(agda2-highlight-postulate-face ((t (:foreground "Orange"))))
 '(agda2-highlight-primitive-face ((t (:foreground "Orange"))))
 '(agda2-highlight-primitive-type-face ((t (:foreground "cyan"))))
 '(agda2-highlight-record-face ((t (:foreground "keyboardFocusIndicatorColor"))))
 '(agda2-highlight-string-face ((t (:foreground "green"))))
 '(agda2-highlight-termination-problem-face ((t (:background "Red4"))))
 '(agda2-highlight-field-face ((t (:foreground "magenta")))))
#+END_SRC

*** Company/Coq mode
#+begin_src emacs-lisp
(custom-set-faces '(company-coq-coqdoc-h1-face ((t (:foreground "magenta")))))
#+end_src
* Flycheck
#+BEGIN_SRC emacs-lisp
;; (global-flycheck-mode)

(eval-after-load "flycheck"
  '(add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode))
#+END_SRC
* File format modes
** LaTeX
** AUCTEX
#+BEGIN_SRC emacs-lisp
;; AUC-TEX

;; Only change sectioning colour
(setq font-latex-fontify-sectioning 'color)
;; super-/sub-script on baseline
(setq font-latex-script-display (quote (nil)))
;; Do not change super-/sub-script font

;; Exclude bold/italic from keywords
(setq font-latex-deactivated-keyword-classes
      '("italic-command" "bold-command" "italic-declaration" "bold-declaration"))

;; More recommended setup
;; (setq TeX-auto-save t)
;; (setq TeX-parse-self t)
;; (setq-default TeX-master nil)

(add-hook 'LaTeX-mode-hook 'flyspell-mode)
;; (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
;; (add-hook 'LaTeX-mode-hook 'turn-on-reftex)

;; (setq reftex-plug-into-AUCTeX t)

;; Look into CDLaTeX

;; Preview LaTeX
;; (add-hook 'LaTeX-mode-hook 'preview-cache-preamble)

(load "auctex.el" nil t t)

(setq preview-auto-cache-preamble t)

;; (add-hook 'LaTeX-mode-hook (kbd "C-c C-p C-b"))

;; TEX ENGINE:
;; (setq-default TeX-engine 'xetex)
(setq-default TeX-engine 'default)


;; Latex math font:
;; (custom-set-faces
;;  '(font-latex-math-face ((t (:family "FreeMono" :height 1.0 :weight bold :foreground "dark khaki")))))

;; Latin Modern Math, Computer Modern
;; Good fonts: STIX General, STIX Mono, DejaVu Sans Mono, ETA, ETA Mono, Source Code Pro, Roboto Mono,
;; Best fonts: fixed, TeX Gyre DejaVu Math, Ubuntu Mono, Latin Modern Mono, Go Mono, Noto Sans Mono, Mitra Mono, Liberation Mono
;; My Choice: TeX Gyre DejaVu Math, FreeMono

;; To see all fonts, uncomment and press C-j the following line:
;; (font-family-list)

;; Start in math mode
(add-hook 'LaTeX-mode-hook 'latex-math-mode)
#+END_SRC

** BEAMER
#+BEGIN_SRC emacs-lisp
(require 'org-tree-slide) ;; Allow slides from within beamer with M-x org-tree-slide-mode

;; allow for export=>beamer by placing

;; #+LaTeX_CLASS: beamer in org files
(unless (boundp 'org-export-latex-classes)
  (setq org-export-latex-classes nil))
(add-to-list 'org-export-latex-classes
  ;; beamer class, for presentations
  '("beamer"
     "\\documentclass[11pt]{beamer}\n
      \\mode<{{{beamermode}}}>\n
      \\usetheme{{{{beamertheme}}}}\n
      \\usecolortheme{{{{beamercolortheme}}}}\n
      \\beamertemplateballitem\n
      \\setbeameroption{show notes}
      \\usepackage[utf8]{inputenc}\n
      \\usepackage[T1]{fontenc}\n
      \\usepackage{hyperref}\n
      \\usepackage{color}
      \\usepackage{listings}
      \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
  frame=single,
  basicstyle=\\small,
  showspaces=false,showstringspaces=false,
  showtabs=false,
  keywordstyle=\\color{blue}\\bfseries,
  commentstyle=\\color{red},
  }\n
      \\usepackage{verbatim}\n
      \\institute{{{{beamerinstitute}}}}\n
       \\subject{{{{beamersubject}}}}\n"

     ("\\section{%s}" . "\\section*{%s}")

     ("\\begin{frame}[fragile]\\frametitle{%s}"
       "\\end{frame}"
       "\\begin{frame}[fragile]\\frametitle{%s}"
       "\\end{frame}")))

  ;; letter class, for formal letters

  (add-to-list 'org-export-latex-classes

  '("letter"
     "\\documentclass[11pt]{letter}\n
      \\usepackage[utf8]{inputenc}\n
      \\usepackage[T1]{fontenc}\n
      \\usepackage{color}"

     ("\\section{%s}" . "\\section*{%s}")
     ("\\subsection{%s}" . "\\subsection*{%s}")
     ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
     ("\\paragraph{%s}" . "\\paragraph*{%s}")
     ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC

** Org mode
#+BEGIN_SRC emacs-lisp
(setq org-startup-folded t)
(add-hook 'org-mode-hook 'org-hide-block-all)
(add-hook 'org-mode-hook (lambda () (setq-local word-wrap nil)))
(setq org-startup-truncated t) ;; non-nil for truncated

;; (add-to-list 'org-babel-default-header-args '(:eval . "never-export"))

(org-babel-do-load-languages
 'org-babel-load-languages '((latex . t)
			     (C . t)
			     (org . t)
			     (python . t)
			     (shell . t)
			     ;; (coq . nil)
			     ))

;; (setq org-confirm-babel-evaluate nil) ;; Maybe bad idea

(add-to-list 'org-file-apps '("\\.pdf\\'" . "evince %s")) ;; xdg-open

(require 'ox-beamer)
;; (add-to-list 'org-export-backends 'beamer)

(setq org-latex-listings t)
;; (setq org-latex-listings 'minted)
;; (setq org-latex-packages-alist '(("" "minted")))
;; (add-to-list 'org-latex-packages-alist '("" "fullpage"))
;; (add-to-list 'org-latex-packages-alist '("" "color"))

;; (setq org-latex-minted-options
;; 	'(("linenos") ("breaklines")))

(setq org-latex-to-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode %f"
	"pdflatex -shell-escape -interaction nonstopmode %f"))
;; '("xelatex -interaction nonstopmode %f"
;;   "xelatex -interaction nonstopmode %f")

;; fontify code in code blocks
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-src-preserve-indentation nil 
      org-edit-src-content-indentation 0)

(setq org-confirm-babel-evaluate 'nil)

(add-to-list 'org-src-lang-modes '("toml" . "conf-toml"))
#+END_SRC

#+begin_src emacs-lisp
  (defun org-edit-src-code (&optional code edit-buffer-name)
    "Edit the source or example block at point.
  \\<org-src-mode-map>
  The code is copied to a separate buffer and the appropriate mode
  is turned on.  When done, exit with `\\[org-edit-src-exit]'.  This \
  will remove the
  original code in the Org buffer, and replace it with the edited
  version.  See `org-src-window-setup' to configure the display of
  windows containing the Org buffer and the code buffer.

  When optional argument CODE is a string, edit it in a dedicated
  buffer instead.

  When optional argument EDIT-BUFFER-NAME is non-nil, use it as the
  name of the sub-editing buffer."
    (interactive)
    (let* ((element (org-element-at-point))
	   (type (org-element-type element)))
      (unless (and (memq type '(example-block src-block))
		   (org-src--on-datum-p element))
	(user-error "Not in a source or example block"))
      (let* ((lang
	      (if (eq type 'src-block) (org-element-property :language element)
		"example"))
	     (lang-f (and (eq type 'src-block) (org-src-get-lang-mode lang)))
	     (babel-info (and (eq type 'src-block)
			      (org-babel-get-src-block-info 'light)))
	     (buff-name (buffer-file-name))
	     deactivate-mark)
	(when (and (eq type 'src-block) (not (functionp lang-f)))
	  (error "No such language mode: %s" lang-f))
	(org-src--edit-element
	 element
	 (or edit-buffer-name
	     (org-src--construct-edit-buffer-name (buffer-name) lang))
	 lang-f
	 (and (null code)
	      (lambda () (org-escape-code-in-region (point-min) (point-max))))
	 (and code (org-unescape-code-in-string code)))
	;; Finalize buffer.
	(setq-local org-coderef-label-format
		    (or (org-element-property :label-fmt element)
			org-coderef-label-format))
	(when (eq type 'src-block)
	  (setq org-src--babel-info babel-info)
	  (let ((file-name (cdr (assoc :tangle (car (cdr (cdr org-src--babel-info)))))))
	    (if (not (string= file-name "no"))
		(setq buffer-file-name (concat (file-name-directory buff-name) file-name))
	      (setq buffer-file-name 'nil)))
	  (let ((edit-prep-func (intern (concat "org-babel-edit-prep:" lang))))
	    (when (fboundp edit-prep-func)
	      (funcall edit-prep-func babel-info))))
	t)))
#+end_src

** C/C++ coding
** Indentation
#+BEGIN_SRC emacs-lisp
  ;; C indentation

  (setq c-default-style "linux"
	c-basic-offset 2
	tab-width 2
	indent-tabs-mode t)
#+END_SRC

** Rust
#+BEGIN_SRC emacs-lisp
(add-hook 'rust-mode-hook
	  (lambda () (setq indent-tabs-mode nil)))
(add-hook 'rust-mode-hook 'yas-minor-mode)
;; (add-hook 'rust-mode-hook
;;           (lambda () (prettify-symbols-mode)))
;; TODO: add yas-mode so rustic does not complain on auto-complete
(setq rust-format-on-save t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (defun rustic-mode-auto-save-hook ()
;;   "Enable auto-saving in rustic-mode buffers."
;;   (when buffer-file-name
;;     (setq-local compilation-ask-about-save nil)))
;; (add-hook 'rustic-mode-hook 'rustic-mode-auto-save-hook)
#+END_SRC
** C++ - Clangd
#+BEGIN_SRC emacs-lisp
;; (setq package-selected-packages '(lsp-mode yasnippet lsp-treemacs ;; helm-lsp
;;     projectile hydra flycheck company avy which-key ;; helm-xref
;;     dap-mode))

;; (when (cl-find-if-not #'package-installed-p package-selected-packages)
;;   (package-refresh-contents)
;;   (mapc #'package-install package-selected-packages))

;; sample `helm' configuration use https://github.com/emacs-helm/helm/ for details
;; (helm-mode)
;; (require 'helm-xref)
;; (define-key global-map [remap find-file] #'helm-find-files)
;; (define-key global-map [remap execute-extended-command] #'helm-M-x)
;; (define-key global-map [remap switch-to-buffer] #'helm-mini)

;; (which-key-mode)
(add-hook 'c-mode-hook 'lsp)
(add-hook 'c++-mode-hook 'lsp)

(setq gc-cons-threshold (* 100 1024 1024)
      read-process-output-max (* 1024 1024)
      treemacs-space-between-root-nodes nil
      company-idle-delay 0.0
      company-minimum-prefix-length 1
      lsp-idle-delay 0.1)  ;; clangd is fast

;; (with-eval-after-load 'lsp-mode
;;   (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)
;;   (require 'dap-cpptools)
;;   (yas-global-mode))
#+END_SRC

** Coq
#+begin_src emacs-lisp
;; (load "~/.emacs.d/lisp/PG/generic/proof-site")
(setq proof-assistant "Coq")
;; (load "/home/au538501/.emacs.d/elpa/proof-general-20220525.1052/coq/coq")

(setq proof-splash-enable nil)
(custom-set-variables
 '(proof-three-window-mode-policy 'hybrid))
#+end_src

*** opam switch
Run `opam user-setup install` to get access to:
#+begin_src emacs-lisp :tangle no
(defun opam-env ()
  (interactive nil)
  (dolist (var (car (read-from-string (shell-command-to-string "opam config env --sexp"))))
    (setenv (car var) (cadr var))))
#+end_src

**** opam-switch-mode
https://github.com/ProofGeneral/opam-switch-mode
#+begin_src emacs-lisp
;;; opam-switch-mode.el --- select opam switches within emacs  -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2021 Hendrik Tews
;;
;; Authors: Hendrik Tews
;; Maintainer: Hendrik Tews <hendrik@askra.de>
;;
;; SPDX-License-Identifier: GPL-3.0-or-later
;;
;; This file is free software: you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation, either version 3 of the
;; License, or (at your option) any later version.
;; 
;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
;; General Public License in file COPYING in this or one of the parent
;; directories for more details.
;; 
;; You should have received a copy of the GNU General Public License
;; along with "prooftree". If not, see <http://www.gnu.org/licenses/>.
;; 
;; 
;;; Commentary:
;;
;; Provide command `opam-switch-set-switch' to change the opam switch
;; of the running emacs session and minor mode `opam-switch-mode' to
;; select the opam switch via a menu bar menu.
;;
;; `opam-switch-set-switch' reads the name of the switch in the
;; minibuffer, providing completion with all available switches. With
;; no input (i.e., leaving the minibuffer empty) the environment is
;; reset to the state before the first call of
;; `opam-switch-set-switch'.
;;
;; The menu is generated each time the minor mode is enabled and
;; contains the switches that are known at that time. If you create a
;; new switch, re-enable the minor mode to get it added to the menu.
;; The menu contains an additional entry "reset" to reset the
;; environment to the state when emacs was started.
;;
;; For obvious reasons, `opam-switch-set-switch' does not change the
;; switch of any other shell.
;;
;; 

(require 'seq)

;;; User options and variables

(defgroup opam-switch-mode ()
  "Customization for opam switch support in Emacs"
  :group 'external)

  
(defcustom opsw--program-name "opam"
  "Name or path of the opam binary."
  :group 'opam-switch-mode
  :type 'string)

(defcustom opsw--common-options ()
  "Options to be supplied to every opam invocation.
This must be a list of strings, each member string an option
accepted by opam."
  :group 'opam-switch-mode
  :type '(repeat string))

(defcustom opsw--common-environment
  '("OPAMUTF8=never"
    "OPAMCOLOR=never"
    "LC_ALL=C")
  "Process environment to be set for every opam invocation.
List of strings compatible with `process-environment', i.e., each
element should have the form of ENVVARNAME=VALUE.

The process environment must ensure that output is plain ascii
without color, non-ascii arrow symbols and that it is in English.
Otherwise parsing the output of opam commands won't work."
  :group 'opam-switch-mode
  :type '(repeat string))

(defcustom opam-switch-change-opam-switch-hook nil
  "Hook run when the opam switch changes.
This is used, for instance, to let Proof General kill the coq
background process when the opam switch changes."
  :group 'opam-switch-mode
  :type '(repeat function))
  

;;; Code

(defun opsw--run-command-without-stderr (sub-cmd
                                        &optional switch sexp
                                        &rest args)
  "Run opam SUB-CMD, without capturing error output.
Run opam SUB-CMD with additional arguments and insert the output
in the current buffer at point. Error output (stderr) is
discarded. If SWITCH is not nil, an option \"--swith=SWITCH\" is
added. If SEXP is t, option --sexep is added. All remaining
arguments ARGS are added as arguments.

Return exit status of the opam invocation.

Internally this function uses `process-file' internally and will
therfore respect file-name handlers specified via
`default-directory'."
  (let ((process-environment
         (append opsw--common-environment process-environment))
        (options (append args opsw--common-options)))
    (when switch
      (push (format "--switch=%s" switch) options))
    (when sexp
      (push "--sexp" options))
    ;; (message "run %s %s %s" opsw--program-name sub-cmd options)
    (apply 'process-file opsw--program-name
               nil '(t nil) nil sub-cmd options)))

(defun opsw--command-as-string (sub-cmd &optional switch sexp &rest args)
  "Return output of opam SUB-CMD as string or nil.
Same as `opsw--run-command-without-stderr' but return all output
as string. Return nil if opam command fails."
  (with-temp-buffer
    (let ((status
           (apply 'opsw--run-command-without-stderr sub-cmd switch sexp args)))
      (if (eq status 0)
          (buffer-string)
        nil))))

(defun opsw--get-root ()
  "Get the opam root directory.
This is the opam variable 'root'."
  (let ((root (opsw--command-as-string "var" nil nil "root")))
    (unless root
      (error "opam var root failed"))
    (when (eq (aref root (1- (length root))) ?\n)
      (setq root (substring root 0 -1)))
    root))

(defconst opsw--root (opsw--get-root)
  "The opam root directory.")

;; Example output of opam switch. The warning is output on stderr.
;;
;; OPAMUTF8=never OPAMCOLOR=never LC_ALL=C opam switch
;; #   switch        compiler                       description
;; ->  4112-coq-812  ocaml-variants.4.11.2+flambda  4112-coq-812
;;     44            ocaml-base-compiler.4.04.0
;;     450-coq-8.9   ocaml-base-compiler.4.05.0     450-coq-8.9
;;     471-no-coq    ocaml-base-compiler.4.07.1     471-no-coq
;;     system        ocaml-system.4.01.0
;;
;; #   switch   compiler      description
;; ->  default  ocaml.4.13.1  default
;;
;; [WARNING] The environment is not in sync with the current switch.
;;           You should run: eval $(opam env)

(defun opsw--get-switches ()
  "Return all opam switches as list of strings."
  (let (opam-switches)
    (with-temp-buffer
      (unless (eq (opsw--run-command-without-stderr "switch") 0)
        ;; opam exit status different from 0 -- some error occured
        (error "opam switch failed"))
      (goto-char (point-min))
      (forward-line)
      (while (re-search-forward "^.. *\\([^ ]*\\).*$" nil t)
        (push (match-string 1) opam-switches))
      opam-switches)))

(defvar opsw--switch-history nil
  "Minibuffer history list for `opsw--set-switch'.")

(defvar opsw--saved-env nil
  "Saved environment variables, overwritten by an opam switch.
This is a list of saved environment variables. Each saved
variable is a list of two strings, the variable and the value.
Set when the first chosen opam switch overwrites the
environment.")

(defvar opsw--saved-exec-path nil
  "Saved value of `exec-path'.
Set when the first chosen opam switch overwrites `exec-path'.")


(defun opsw--save-current-env (opam-env)
  "Save the current environment values relevant to opam.
Argument OPAM-ENV, coming from calling `opam env', is only used
to find the environment variables to save. `exec-path' is saved
in addition to environment variables."
  (setq opsw--saved-env
	(mapcar (lambda (x) (list (car x) (getenv (car x)))) opam-env))
  (setq opsw--saved-exec-path exec-path))
  
(defun opsw--set-env (opam-env)
  "Sets a new opam environment.
Environment variables in OPAM-ENV are put into the environment of
the current Emacs session. `exec-path' is changed to match the
environment PATH.

It is unclear which value in `exec-path' corresponds to a
previously set opam switch and also which entry in the PATH
environment variable in OPAM-ENV corresponds to the new switch.
Therefore this function uses the following heuristic. First all
entries in `exec-path' that match `opsw--root' are deleted. Then,
the first entry for PATH that maches `opsw--root' is added at the
front of `exec-path'."
  (let ((new-bin-dir
         (seq-find
          (lambda (dir) (string-prefix-p opsw--root dir))
          (parse-colon-path (cadr (assoc "PATH" opam-env))))))
    (unless new-bin-dir
      (error "No opam-root directory in PATH"))
    (mapc (lambda (x) (setenv (car x) (cadr x))) opam-env)
    (setq exec-path
          (seq-remove (lambda (dir) (string-prefix-p opsw--root dir)) exec-path))
    (push new-bin-dir exec-path)))
  
(defun opsw--reset-env ()
  "Reset process environment to the state before setting the first opam switch.
Reset all environment variables and `exec-path' to the values
they had in this emacs session before the first chosen opam
switch overwrote them."
  (mapc (lambda (x) (setenv (car x) (cadr x))) opsw--saved-env)
  (setq exec-path opsw--saved-exec-path)
  (setq opsw--saved-env nil)
  (setq opsw--saved-exec-path nil))


(defun opsw--get-current-switch ()
  "Return name of current switch or \"<none>\"."
  (let ((current-switch (getenv "OPAM_SWITCH_PREFIX")))
    (if current-switch
         (file-name-nondirectory current-switch)
      "<none>")))

(defun opsw--set-switch (switch-name)
  "Chose and set an opam switch.
Set opam switch SWITCH-NAME, which must be a valid opam switch
name. When called interactively, the switch name must be entered
in the minibuffer, which forces completion to a valid switch name
or the empty string.

Setting the opam switch for the first time inside emacs will save
the current environment. Using the empty string for SWITCH-NAME
will reset the environment to the saved values.

The switch is set such that all process invocations from
emacs respect the newly set opam switch. In addition to setting
environment variables such as PATH and CAML_LD_LIBRARY_PATH, this
also sets `exec-path', which controls emacs'
subprocesses (`call-process', `make-process' and similar
functions).

When the switch is changed, `opam-switch-change-opam-switch-hook'
runs. This a can be used to inform other modes that may run
background processes that depend on the currently active opam
switch.

For obvious resons, `opsw--set-switch' will only affect emacs and
not any other shells outside emacs."
  (interactive
   (let* ((switches (opsw--get-switches))
          (current-switch (opsw--get-current-switch)))
     (list
      (completing-read
       (format "current switch %s; switch to (empty to reset): " current-switch)
       switches nil t "" 'opsw--switch-history nil))))
  (when (and (equal switch-name "") (not opsw--saved-env))
    (error "No saved opam environment, cannot reset."))
  (if (equal switch-name "")
      (opsw--reset-env)
    (let ((output-string (opsw--command-as-string "env" switch-name t))
          opam-env)
      (unless output-string
        (error
         "opam env %s failed - probably because of invalid opam switch \"%s\""
         switch-name switch-name))
      (setq opam-env (car (read-from-string output-string)))
      (unless opsw--saved-env
        (opsw--save-current-env opam-env))
      (opsw--set-env opam-env)))
  (run-hooks 'opam-switch-change-opam-switch-hook))

(defalias 'opam-switch-set-switch #'opsw--set-switch)

;;; minor mode, keymap and menu

(defvar opsw--mode-keymap (make-sparse-keymap)
  "Keymap for `opam-switch-mode'")

(defun opsw--menu-items ()
  "Create list of opam switches as menu items for `easy-menu'."
  (nconc
   ;; first the current switch as info with a separator
   '(["current switch: " nil
      :active t
      :suffix (opsw--get-current-switch)
      :help "Shows the currently selected opam switch"]
     "-------")
   ;; then the list with all the real opam switches
   (mapcar
    (lambda (switch)
      (vconcat
       `(,switch
         (opsw--set-switch ,switch)
         :active t
         :help ,(concat "select opam switch \"" switch "\""))))
    (opsw--get-switches))
   ;; now reset as last element
   '(
     ["reset" (opsw--set-switch "")
      :active opsw--saved-env
      :help "reset to state when emacs was started"]
     )))

(defun opsw--setup-opam-switch-mode ()
  "Re-define menu for `opam-switch-mode'.
This function runs when `opam-switch-mode' is enabled to setup
`opam-switch-mode'. Currently it only redefines the menu.

Note that the code for setting up the keymap and running the hook
is automatically created by `define-minor-mode'."
  (easy-menu-define
    opsw--mode-menu
    opsw--mode-keymap
    "opam mode menu"
    (cons "opam-switch"
          (opsw--menu-items))))

(define-minor-mode opam-switch-mode
  "Toggle opam mode"
  ;; init value - should be nil
  nil
  ;; lighter
  " OPSW"
  ;; keymap
  opsw--mode-keymap
  :group 'opam-switch-mode
  ;; body
  (when opam-switch-mode
    (opsw--setup-opam-switch-mode)))

(provide 'opam-switch-mode)
#+end_src

*** Coq setup
#+BEGIN_SRC emacs-lisp
(exec-path-from-shell-initialize)

;; (setq coq-prog-name "~/.opam/4.11.1/bin/coqtop")
;; (setq coq-prog-name "~/.opam/4.07.1+flambda/bin/coqtop")
;; (setq coq-prog-name "~/.opam/4.05.0/bin/coqtop")
;; (setq coq-prog-name "~/.opam/default/bin/coqtop")
;; (setq coq-prog-name "~/.opam/default/bin/coqtop")
;; (setq coq-prog-name "~/.opam/hacspec_coq/bin/coqtop")

(defun find-prog-name (prog)
  (let* ((command (concat "type -p " prog))
         (output (shell-command-to-string command)))
    (replace-regexp-in-string "\n" "" output)))

(defun coq-update-bins ()
  "Update Coq binaries based on the current PATH"
  (interactive)
  (setq coq-compiler (find-prog-name "coqc"))
  (setq coq-prog-name (find-prog-name "coqtop"))
  (setq coq-dependency-analyzer (find-prog-name "coqdep"))
  (when (proof-shell-available-p) (proof-shell-exit)))

(defun coq-opam-env ()
  "Run \"opam env\" and update Coq binaries"
  (interactive)
  (opam-env)
  (coq-update-bins))

;; Load company-coq when opening Coq files
(add-hook 'coq-mode-hook #'company-coq-mode)

#+END_SRC

#+begin_src emacs-lisp :tangle no
  ;;; inferior-coq.el --- Run an inferior Coq process.
  ;;;
  ;;; Copyright (C) Marco Maggesi <maggesi@math.unifi.it>
  ;;; Time-stamp: "2002-02-28 12:15:04 maggesi"


  ;; Emacs Lisp Archive Entry
  ;; Filename: inferior-coq.el
  ;; Version: 1.0
  ;; Keywords: process coq
  ;; Author: Marco Maggesi <maggesi@math.unifi.it>
  ;; Maintainer: Marco Maggesi <maggesi@math.unifi.it>
  ;; Description: Run an inferior Coq process.
  ;; URL: http://www.math.unifi.it/~maggesi/
  ;; Compatibility: Emacs20, Emacs21, XEmacs21

  ;; This is free software; you can redistribute it and/or modify it under
  ;; the terms of the GNU General Public License as published by the Free
  ;; Software Foundation; either version 2, or (at your option) any later
  ;; version.
  ;;
  ;; This is distributed in the hope that it will be useful, but WITHOUT
  ;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  ;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  ;; for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs; see the file COPYING.  If not, write to the
  ;; Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  ;; MA 02111-1307, USA.

  ;;; Commentary:

  ;; Coq is a proof assistant (http://coq.inria.fr/).  This code run an
  ;; inferior Coq process and defines functions to send bits of code
  ;; from other buffers to the inferior process.  This is a
  ;; customisation of comint-mode (see comint.el).  For a more complex
  ;; and full featured Coq interface under Emacs look at Proof General
  ;; (http://zermelo.dcs.ed.ac.uk/~proofgen/).
  ;;
  ;; Written by Marco Maggesi <maggesi@math.unifi.it> with code heavly
  ;; borrowed from emacs cmuscheme.el
  ;;
  ;; Please send me bug reports, bug fixes, and extensions, so that I can
  ;; merge them into the master source.

  ;;; Installation:

  ;; You need to have coq.el already installed (it comes with the
  ;; standard Coq distribution) in order to use this code.  Put this
  ;; file somewhere in you load-path and add the following lines in your
  ;; "~/.emacs":
  ;;
  ;;   (setq auto-mode-alist (cons '("\\.v$" . coq-mode) auto-mode-alist))
  ;;   (autoload 'coq-mode "coq" "Major mode for editing Coq vernacular." t)
  ;;   (autoload 'run-coq "inferior-coq" "Run an inferior Coq process." t)
  ;;   (autoload 'run-coq-other-window "inferior-coq"
  ;;     "Run an inferior Coq process in a new window." t)
  ;;   (autoload 'run-coq-other-frame "inferior-coq"
  ;;     "Run an inferior Coq process in a new frame." t)

  ;;; Usage:

  ;; Call `M-x "run-coq'.
  ;;
  ;; Functions and key bindings (Learn more keys with `C-c C-h' or `C-h m'):
  ;;   C-return ('M-x coq-send-line)     send the current line.
  ;;   C-c C-r  (`M-x coq-send-region')  send the current region.
  ;;   C-c C-a  (`M-x coq-send-abort')   send the command "Abort".
  ;;   C-c C-t  (`M-x coq-send-restart') send the command "Restart".
  ;;   C-c C-s  (`M-x coq-send-show')    send the command "Show".
  ;;   C-c C-u  (`M-x coq-send-undo')    send the command "Undo".
  ;;   C-c C-v  (`M-x coq-check-region') run command "Check" on region.
  ;;   C-c .    (`M-x coq-come-here')    Restart and send until current point.

  ;;; Change Log:

  ;; From -0.0 to 1.0 brought into existence.


  ;; ~/.emacs.d/elpa/proof-general-20211215.1823/coq/coq.el
  (require 'coq)
  (require 'comint)

  (setq coq-program-name "coqtop")

  (defgroup inferior-coq nil
    "Run a coq process in a buffer."
    :group 'coq)

  (defcustom inferior-coq-mode-hook nil
    "*Hook for customising inferior-coq mode."
    :type 'hook
    :group 'coq)

  (defvar inferior-coq-mode-map
    (let ((m (make-sparse-keymap)))
      (define-key m "\C-c\C-r" 'coq-send-region)
      (define-key m "\C-c\C-a" 'coq-send-abort)
      (define-key m "\C-c\C-t" 'coq-send-restart)
      (define-key m "\C-c\C-s" 'coq-send-show)
      (define-key m "\C-c\C-u" 'coq-send-undo)
      (define-key m "\C-c\C-v" 'coq-check-region)
      m))

  ;; Install the process communication commands in the coq-mode keymap.
  (define-key coq-mode-map [(control return)] 'coq-send-line)
  (define-key coq-mode-map "\C-c\C-r" 'coq-send-region)
  (define-key coq-mode-map "\C-c\C-a" 'coq-send-abort)
  (define-key coq-mode-map "\C-c\C-t" 'coq-send-restart)
  (define-key coq-mode-map "\C-c\C-s" 'coq-send-show)
  (define-key coq-mode-map "\C-c\C-u" 'coq-send-undo)
  (define-key coq-mode-map "\C-c\C-v" 'coq-check-region)
  (define-key coq-mode-map "\C-c." 'coq-come-here)

  (defvar coq-buffer)

  (define-derived-mode inferior-coq-mode comint-mode "Inferior Coq"
    "\
  Major mode for interacting with an inferior Coq process.

  The following commands are available:
  \\{inferior-coq-mode-map}

  A Coq process can be fired up with M-x run-coq.

  Customisation: Entry to this mode runs the hooks on comint-mode-hook
  and inferior-coq-mode-hook (in that order).

  You can send text to the inferior Coq process from other buffers
  containing Coq source.

  Functions and key bindings (Learn more keys with `C-c C-h'):
    C-return ('M-x coq-send-line)     send the current line.
    C-c C-r  (`M-x coq-send-region')  send the current region.
    C-c C-a  (`M-x coq-send-abort')   send the command \"Abort\".
    C-c C-t  (`M-x coq-send-restart') send the command \"Restart\".
    C-c C-s  (`M-x coq-send-show')    send the command \"Show\".
    C-c C-u  (`M-x coq-send-undo')    send the command \"Undo\".
    C-c C-v  (`M-x coq-check-region') run command \"Check\" on region.
    C-c .    (`M-x coq-come-here')    Restart and send until current point.
  "
    ;; Customise in inferior-coq-mode-hook
    (setq comint-prompt-regexp "^[^<]* < *")
    (coq-mode-variables)
    (setq mode-line-process '(":%s"))
    (setq comint-input-filter (function coq-input-filter))
    (setq comint-get-old-input (function coq-get-old-input)))

  (defcustom inferior-coq-filter-regexp "\\`\\s *\\S ?\\S ?\\s *\\'"
    "*Input matching this regexp are not saved on the history list.
  Defaults to a regexp ignoring all inputs of 0, 1, or 2 letters."
    :type 'regexp
    :group 'inferior-coq)

  (defun coq-input-filter (str)
    "Don't save anything matching `inferior-coq-filter-regexp'."
    (not (string-match inferior-coq-filter-regexp str)))

  (defun coq-get-old-input ()
    "Snarf the sexp ending at point."
    (save-excursion
      (let ((end (point)))
	(backward-sexp)
	(buffer-substring (point) end))))

  (defun coq-args-to-list (string)
    (let ((where (string-match "[ \t]" string)))
      (cond ((null where) (list string))
	    ((not (= where 0))
	     (cons (substring string 0 where)
		   (coq-args-to-list (substring string (+ 1 where)
						   (length string)))))
	    (t (let ((pos (string-match "[^ \t]" string)))
		 (if (null pos)
		     nil
		   (coq-args-to-list (substring string pos
						   (length string)))))))))

  ;;;###autoload
  (defun run-coq (cmd)
    "Run an inferior Coq process, input and output via buffer *coq*.
  If there is a process already running in `*coq*', switch to that buffer.
  With argument, allows you to edit the command line (default is value
  of `coq-program-name').  Runs the hooks `inferior-coq-mode-hook'
  \(after the `comint-mode-hook' is run).
  \(Type \\[describe-mode] in the process buffer for a list of commands.)"

    (interactive (list (if current-prefix-arg
			   (read-string "Run Coq: " coq-program-name)
			   coq-program-name)))
    (if (not (comint-check-proc "*coq*"))
	(let ((cmdlist (coq-args-to-list cmd)))
	  (set-buffer (apply 'make-comint "coq" (car cmdlist)
			     nil (cdr cmdlist)))
	  (inferior-coq-mode)))
    (setq coq-program-name cmd)
    (setq coq-buffer "*coq*")
    (switch-to-buffer "*coq*"))
  ;;;###autoload (add-hook 'same-window-buffer-names "*coq*")

  ;;;###autoload
  (defun run-coq-other-window (cmd)
    "Run an inferior Coq process, input and output via buffer *coq*.
  If there is a process already running in `*coq*', switch to that buffer.
  With argument, allows you to edit the command line (default is value
  of `coq-program-name').  Runs the hooks `inferior-coq-mode-hook'
  \(after the `comint-mode-hook' is run).
  \(Type \\[describe-mode] in the process buffer for a list of commands.)"

    (interactive (list (if current-prefix-arg
			   (read-string "Run Coq: " coq-program-name)
			   coq-program-name)))
    (if (not (comint-check-proc "*coq*"))
	(let ((cmdlist (coq-args-to-list cmd)))
	  (set-buffer (apply 'make-comint "coq" (car cmdlist)
			     nil (cdr cmdlist)))
	  (inferior-coq-mode)))
    (setq coq-program-name cmd)
    (setq coq-buffer "*coq*")
    (pop-to-buffer "*coq*"))
  ;;;###autoload (add-hook 'same-window-buffer-names "*coq*")

  (defun run-coq-other-frame (cmd)
    "Run an inferior Coq process, input and output via buffer *coq*.
  If there is a process already running in `*coq*', switch to that buffer.
  With argument, allows you to edit the command line (default is value
  of `coq-program-name').  Runs the hooks `inferior-coq-mode-hook'
  \(after the `comint-mode-hook' is run).
  \(Type \\[describe-mode] in the process buffer for a list of commands.)"

    (interactive (list (if current-prefix-arg
			   (read-string "Run Coq: " coq-program-name)
			   coq-program-name)))
    (if (not (comint-check-proc "*coq*"))
	(let ((cmdlist (coq-args-to-list cmd)))
	  (set-buffer (apply 'make-comint "coq" (car cmdlist)
			     nil (cdr cmdlist)))
	  (inferior-coq-mode)))
    (setq coq-program-name cmd)
    (setq coq-buffer "*coq*")
    (switch-to-buffer-other-frame "*coq*"))

  (defun switch-to-coq (eob-p)
    "Switch to the coq process buffer.
  With argument, position cursor at end of buffer."
    (interactive "P")
    (if (get-buffer coq-buffer)
	(pop-to-buffer coq-buffer)
	(error "No current process buffer.  See variable `coq-buffer'"))
    (cond (eob-p
	   (push-mark)
	   (goto-char (point-max)))))

  (defun coq-send-region (start end)
    "Send the current region to the inferior Coq process."
    (interactive "r")
    (comint-send-region (coq-proc) start end)
    (comint-send-string (coq-proc) "\n"))

  (defun coq-send-line ()
    "Send the current line to the Coq process."
    (interactive)
    (save-excursion
      (end-of-line)
      (let ((end (point)))
	(beginning-of-line)
	(coq-send-region (point) end)))
    (next-line 1))

  (defun coq-send-back ()
    "Send a 'Go one step back' instruction to Coq process."
    (interactive)
    (comint-send-string (coq-proc) "Back.\n"))

  (defun coq-send-reset-ident ()
    "Send a 'Go to ident' instruction to Coq process."
    (interactive)
    (comint-send-string (coq-proc) (concat (concat "Reset " (read-string "Coq Ident: ")) ".\n")))

  (defun coq-send-abort ()
    "Send the command \"Abort.\" to the inferior Coq process."
    (interactive)
    (comint-send-string (coq-proc) "Abort.\n"))

  (defun coq-send-restart ()
    "Send the command \"Restart.\" to the inferior Coq process."
    (interactive)
    (comint-send-string (coq-proc) "Restart.\n"))

  (defun coq-send-undo ()
    "Reset coq to the initial state and send the region between the
     beginning of file and the point."
    (interactive)
    (comint-send-string (coq-proc) "Undo.\n"))

  (defun coq-check-region (start end)
    "Run the commmand \"Check\" on the current region."
    (interactive "r")
    (comint-proc-query (coq-proc)
		       (concat "Check "
			       (buffer-substring start end)
			       ".\n")))

  (defun coq-send-show ()
    "Send the command \"Show.\" to the inferior Coq process."
    (interactive)
    (comint-send-string (coq-proc) "Show.\n"))

  (defun coq-come-here ()
    "Reset coq to the initial state and send the region between the
     beginning of file and the point."
    (interactive)
    (comint-send-string (coq-proc) "Reset Initial.\n")
    (coq-send-region 1 (point)))

  (defvar coq-buffer nil "*The current coq process buffer.")

  (defun coq-proc ()
    "Return the current coq process.  See variable `coq-buffer'."
    (let ((proc (get-buffer-process (if (eq major-mode 'inferior-coq-mode)
					(current-buffer)
					coq-buffer))))
      (or proc
	  (error "No current process.  See variable `coq-buffer'"))))

  (defcustom inferior-coq-load-hook nil
    "This hook is run when inferior-coq is loaded in.
  This is a good place to put keybindings."
    :type 'hook
    :group 'inferior-coq)

  (run-hooks 'inferior-coq-load-hook)

  (provide 'inferior-coq)
#+end_src

#+begin_src emacs-lisp :tangle no
(setq auto-mode-alist (cons '("\\.v$" . coq-mode) auto-mode-alist))
(autoload 'coq-mode "coq" "Major mode for editing Coq vernacular." t)
(autoload 'run-coq "inferior-coq" "Run an inferior Coq process." t)
(autoload 'run-coq-other-window "inferior-coq"
  "Run an inferior Coq process in a new window." t)
(autoload 'run-coq-other-frame "inferior-coq"
  "Run an inferior Coq process in a new frame." t)
#+end_src

#+begin_src emacs-lisp  :tangle no
(defvar emacsd-dir "/home/au538501/.emacs.d/") ;
(setq package-user-dir (concat emacsd-dir "elpa"))

;; (package-initialize)

(require 'org)
(require 'ox-html)

(setq org-html-postamble nil)
(setq org-confirm-babel-evaluate nil)

(require 'comint)

(defvar coq-program-name "coqtop")

(defvar coq-buffer)

(define-derived-mode inferior-coq-mode comint-mode "Run Coq"
  ""
  (setq comint-prompt-regexp "^[^<]* < *"))

(defun coq-args-to-list (string)
  (let ((where (string-match "[ \t]" string)))
    (cond ((null where) (list string))
    ((not (= where 0))
     (cons (substring string 0 where)
     (coq-args-to-list (substring string (+ 1 where)
	     (length string)))))
    (t (let ((pos (string-match "[^ \t]" string)))
	 (if (null pos)
       nil
     (coq-args-to-list (substring string pos
	     (length string)))))))))

(defun run-coq (cmd)
  (interactive (list (if current-prefix-arg
       (read-string "Run Coq: " coq-program-name)
       coq-program-name)))
  (if (not (comint-check-proc "*coq*"))
      (let ((cmdlist (coq-args-to-list cmd)))
  (set-buffer (apply 'make-comint "coq" (car cmdlist)
	 nil (cdr cmdlist)))
  (inferior-coq-mode)))
  (setq coq-program-name cmd)
  (setq coq-buffer "*coq*")
  (switch-to-buffer "*coq*"))

(defun coq-proc ()
  "Return the current coq process.  See variable `coq-buffer'."
  (let ((proc (get-buffer-process (if (eq major-mode 'inferior-coq-mode)
	      (current-buffer)
	      coq-buffer))))
    (or proc
  (error "No current process.  See variable `coq-buffer'"))))

(org-babel-do-load-languages
 'org-babel-load-languages
 '((coq . t)))

;; I need to redefine these function, as they have some issues.

(defun org-babel-coq-split-phrases (body)
  (split-string body "\\.[ \t\n\r]+"))

(defun org-babel-coq-run-one-phrase (phrase session)
  (let ((pt (lambda ()
	(marker-position
	 (process-mark (get-buffer-process (current-buffer)))))))
    (org-babel-coq-clean-prompt
     (org-babel-comint-in-buffer session
       (let ((start (funcall pt)))
   (with-temp-buffer
     (insert phrase)
     (comint-send-region (coq-proc) (point-min) (point-max))
     (comint-send-string (coq-proc)
      (if (string= (buffer-substring (- (point-max) 1) (point-max)) ".")
    "\n"
	".\n")))
   (while (equal start (funcall pt)) (sleep-for 0.1))
   (buffer-substring start (funcall pt)))))))

(defun org-babel-execute:coq (body params)
  (let ((full-body (org-babel-expand-body:generic body params))
	(session (org-babel-coq-initiate-session)))
    (let ((phrases (org-babel-coq-split-phrases full-body))
	  results)
      (while phrases
	(unless (string-match "^\s*\\'" (car phrases))
	  (setq results
		(cons (org-babel-coq-run-one-phrase (car phrases) session) results)))
	(setq phrases (cdr phrases)))
      (apply #'concat (reverse results)))))

(defun org-babel-coq-initiate-session ()
  "Initiate a coq session.
If there is not a current inferior-process-buffer in SESSION then
create one.  Return the initialized session."
  (unless (fboundp 'run-coq)
    (error "`run-coq' not defined, load coq-inferior.el"))
  (save-window-excursion (run-coq coq-program-name))
  (sit-for 0.1)
  (get-buffer org-babel-coq-buffer))	;
#+end_src
** GO
#+begin_src elisp
;; (add-to-list 'load-path "/place/where/you/put/it/")
(autoload 'go-mode "go-mode" nil t)
(add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))
#+end_src
** Ocaml
#+begin_src elisp
(add-to-list 'load-path "/home/au538501/.opam/hacspec-v2/share/emacs/site-lisp")
(require 'ocp-indent)
#+end_src

* Git / Version control
** Magit
#+BEGIN_SRC emacs-lisp
;; (global-set-key (kbd "C-x g") 'magit-status) ;; Shows commit status
;; (setq magit-bury-buffer-function
;;       (lambda (con)
;; 	(kill-buffer)
;; 	(delete-window)))
#+END_SRC

* LSP
** Rust
#+BEGIN_SRC emacs-lisp
(setq lsp-rust-server 'rust-analyzer)
;; (add-hook 'rust-mode-hook #'lsp)
#+END_SRC
** Grammerly
# https://github.com/emacs-grammarly/grammarly-language-server
#+begin_src bash :tangle no
npm config set prefix ~/.npm-packages # configure it to install "globally installed packages"
npm install -g @emacs-grammarly/grammarly-languageserver # install the grammarly languageserver
#+end_src
install an emacs frontend for the server from https://github.com/emacs-grammarly
# Grammarly-ls

# Grammarly describe: s-l h h
# Grammarly action: s-l a a

# s-
# C-x @ s

# h-
# C-x @ h

#+begin_src emacs-lisp
(use-package lsp-grammarly
  :ensure t
  :hook (text-mode . (lambda ()
                       (require 'lsp-grammarly)
                       (lsp))))  ; or lsp-deferred
#+end_src

* Guides
https://www.emacswiki.org/emacs/Reference_Sheet_by_Aaron_Hawley
* Languagetool
#+begin_src emacs-lisp
(use-package languagetool
  :ensure t
  :defer t
  :commands (languagetool-check
             languagetool-clear-suggestions
             languagetool-correct-at-point
             languagetool-correct-buffer
             languagetool-set-language
             languagetool-server-mode
             languagetool-server-start
             languagetool-server-stop)
  :config
  (setq languagetool-java-arguments '("-Dfile.encoding=UTF-8")
        languagetool-console-command "/snap/languagetool/current/usr/bin/languagetool-commandline.jar"
        languagetool-server-command "/snap/languagetool/current/usr/bin/languagetool-server.jar"))

(use-package flycheck-languagetool
  :ensure t
  :hook (text-mode . flycheck-languagetool-setup)
  :init
  (setq flycheck-languagetool-server-jar "/snap/languagetool/current/usr/bin/languagetool-server.jar"))
#+end_src
* Evil
#+begin_src emacs-lisp
;; ;; Enable Evil
;; (require 'evil)
;; (evil-mode 1)

;; Visual line numbers
(setq-default display-line-numbers 'visual
              display-line-numbers-widen 'nil
              ;; this is the default
              display-line-numbers-current-absolute t)

(setq display-line-numbers-width 4)

(defun noct-relative ()
  "Show relative line numbers."
  (setq-local display-line-numbers 'visual))

(defun noct-absolute ()
  "Show absolute line numbers."
  (setq-local display-line-numbers t))

(add-hook 'evil-insert-state-entry-hook #'noct-relative)
(add-hook 'evil-insert-state-exit-hook #'noct-relative)

;; example of customizing colors
(custom-set-faces '(line-number-current-line ((t :weight bold
                                                 :foreground "goldenrod"
                                                 :background "slate gray"))))

;; (setq evil-emacs-state-modes nil)
;; (setq evil-insert-state-modes nil)
;; (setq evil-motion-state-modes nil)
;; (setq evil-mode-line-format nil
;;       evil-insert-state-cursor '(bar "White")
;;       evil-visual-state-cursor '(box "#F86155"))
#+end_src
